{-# LANGUAGE OverloadedStrings #-}
module Main where

import Rest
import Rest.Api
import Data.Aeson
import qualified Data.JSON.Schema.Types as T
import Control.Monad.Reader
import Rest.Driver.Happstack
import Data.Monoid
import Control.Monad
import Data.Functor
import Control.Applicative
import Control.Monad.IO.Class (liftIO)
import Happstack.Server.SimpleHTTP
import qualified Rest.Resource as R

postResource = mkResourceReader 
     {
       R.name = "post"
     , R.schema = withListing () $ named [("title",singleBy id)]
     , R.list = const list
     , R.get = Just get
     }

data Post = Post {title :: String, content :: String}

instance FromJSON Post where
  parseJSON (Object v) = Post <$>
                         v .: "post" <*>
                         v .: "content"
  parseJSON _ = mzero
instance ToJSON Post where
  toJSON (Post title content) = object ["title" .= title, "content" .= content]

instance T.JSONSchema Post where
  schema = T.Any
  
testPost:: IO Post
testPost = return $ Post "hi reggie" "strings are inneficient in haskell sorry guys lol"

get:: Handler (ReaderT String IO)
get = mkIdHandler jsonO $ \_ title -> liftIO $ testPost


list = mkListing jsonO $ \_ -> liftIO $ sequence [testPost, testPost]

blog = root -/ (route postResource)
api = [(mkVersion 1 0 0, Some1 blog)]
handle = apiToHandler' liftIO api

main = simpleHTTP nullConf handle
